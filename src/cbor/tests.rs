#[cfg(not(feature = "tarpaulin"))]
use super::external::fallback_decoder::FallbackDecoder;
#[cfg(not(feature = "tarpaulin"))]
use num_cpus;

#[cfg(not(feature = "tarpaulin"))]
use pallas_hardano::display::haskell_error::serialize_error;
use serde::Deserialize;
use std::process::Command;

#[cfg(not(feature = "tarpaulin"))]
mod random;
#[cfg(not(feature = "tarpaulin"))]
mod random_eval_tx;
#[cfg(not(feature = "tarpaulin"))]
mod specific;

#[cfg(not(feature = "tarpaulin"))]
mod test_data;

#[derive(Deserialize, Debug)]
#[serde(rename_all(deserialize = "camelCase"))]
pub struct CborTestCase {
    pub cbor: String,
    pub haskell_repr: String,
    pub json: serde_json::Value,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all(deserialize = "camelCase"))]
pub struct CborTestSeed {
    pub seed: i64,
}

#[derive(Debug, Clone, Copy)]
#[allow(non_camel_case_types, dead_code)]
pub enum CaseType {
    Tx_Conway,
    ApplyTxErr_Byron,
    ApplyTxErr_Shelley,
    ApplyTxErr_Allegra,
    ApplyTxErr_Mary,
    ApplyTxErr_Alonzo,
    ApplyTxErr_Babbage,
    ApplyTxErr_Conway,
    GHCInteger,
    DataText,
    ExampleADT,
}

/// This function will run your `check_one` function in parallel on all
/// available CPUs, for the cases generated by `testgen-hs`, and report the
/// overall stats and first N failures. You can either panic or return a
/// `Result`.
pub fn check_generated_cases<F>(
    case_type: CaseType,
    num_cases: u32,
    generator_size: u16,
    show_n_failures: u32,
    seed: Option<u64>,
    check_one: F,
) where
    F: Fn(CborTestCase) -> Result<(), String> + Send + Copy + std::panic::RefUnwindSafe,
{
    use std::io::{BufRead, BufReader};

    let child_exe = super::external::testgen::Testgen::find_testgen_hs().unwrap();

    let mut child = Command::new(&child_exe)
        .arg("generate")
        .args(["--number", &num_cases.to_string()])
        .args(["--generator-size", &generator_size.to_string()])
        .args(seed.map_or(vec![], |seed| vec!["--seed".to_string(), seed.to_string()]))
        .arg(format!("{case_type:?}"))
        .stdout(std::process::Stdio::piped())
        .spawn()
        .expect("failed to spawn child");

    let mut stdout =
        BufReader::new(child.stdout.take().expect("failed to take child stdout")).lines();

    let random_seed = {
        let first_line = stdout.next().unwrap().unwrap();
        serde_json::from_str::<CborTestSeed>(&first_line)
            .unwrap()
            .seed
    };

    // Using a `bounded(0)` channels (i.e. with no buffering), because we want
    // maximum backpressure for minimum resource consumption.
    let (work_tx, work_rx) = crossbeam::channel::bounded::<String>(0);
    let (result_tx, result_rx) = crossbeam::channel::bounded::<Result<(), String>>(0);

    let num_threads = num_cpus::get();

    std::thread::scope(|ts| {
        // Start worker threads:
        for _ in 0..num_threads {
            let work_rx = work_rx.clone();
            let result_tx = result_tx.clone();

            ts.spawn(move || {
                for line in work_rx {
                    let parsed = serde_json::from_str::<CborTestCase>(&line);
                    let outcome = match parsed {
                        Ok(test_case) => match std::panic::catch_unwind(|| check_one(test_case)) {
                            Ok(a) => a,
                            Err(_) => Err("panic! (see above for details)".to_string()),
                        },
                        Err(e) => Err(format!("CborTestCase JSON parse error: {e}")),
                    };
                    let _ = result_tx.send(outcome);
                }
            });
        }

        // Drop our main thread sender, so that when all worker threads are
        // finished, weâ€™ll see no active `result_tx` senders, and the results
        // channel will be closed automatically:
        drop(result_tx);

        // Get and schedule new work with backpressure from the workers:
        ts.spawn(move || {
            for line in stdout {
                let line = line.unwrap();
                let _ = work_tx.send(line);
            }
            drop(work_tx);
        });

        // Collect the results:
        let mut num_failed = 0;
        let mut num_total = 0;
        let mut first_n_failures: Vec<String> = vec![];
        for result in result_rx {
            num_total += 1;
            if let Err(e) = result {
                num_failed += 1;
                if first_n_failures.len() < show_n_failures as usize {
                    first_n_failures.push(e);
                }
            }
        }

        // Reaping a potential zombie:
        child.wait().unwrap();

        if num_failed > 0 {
            let percent = num_failed as f64 / num_total as f64 * 100.0;
            let mut details = "".to_string();

            if !first_n_failures.is_empty() {
                details.push_str(&format!(
                    " Failing CBORs{}:",
                    if num_failed <= show_n_failures {
                        "".to_string()
                    } else {
                        format!(" (first {show_n_failures})")
                    }
                ));

                for case in first_n_failures {
                    details.push_str(&format!("\n- {case}"));
                }
            }

            panic!(
                "For size {generator_size}: {num_failed} out of {num_total} ({percent:.2}%) failed. Seed: {random_seed}.{details}"
            )
        }
    });
}
#[cfg(not(feature = "tarpaulin"))]
macro_rules! assert_json_eq {
    ($left:expr, $right:expr) => {
        if $left != $right {
            let left_pretty = serde_json::to_string_pretty(&$left).unwrap();
            let right_pretty = serde_json::to_string_pretty(&$right).unwrap();
            panic!(
                concat!(
                    "assertion `left == right` failed\n",
                    "  left:\n    {}\n  right:\n    {}",
                ),
                left_pretty.replace("\n", "\n    "),
                right_pretty.replace("\n", "\n    "),
            );
        }
    };
}
#[cfg(not(feature = "tarpaulin"))]
pub(crate) use assert_json_eq; // export it

/// This function takes a CBOR-encoded `ApplyTxErr`, and verifies our
/// deserializer against the Haskell one. Use it for specific cases.
#[cfg(not(feature = "tarpaulin"))]
async fn verify_one(cbor: &str) {
    let cbor = hex::decode(cbor).unwrap();
    let reference_json = FallbackDecoder::instance().decode(&cbor).await.unwrap();

    let our_decoding = decode_error(&cbor);

    let our_json = serialize_error(our_decoding);
    assert_json_eq!(reference_json, our_json)
}
#[cfg(not(feature = "tarpaulin"))]
use pallas_network::miniprotocols::localtxsubmission::TxValidationError;

#[cfg(test)]
#[cfg(not(feature = "tarpaulin"))]
fn decode_error(cbor: &[u8]) -> TxValidationError {
    use pallas_codec::minicbor;

    let mut decoder = minicbor::Decoder::new(cbor);
    decoder.decode().unwrap()
}
